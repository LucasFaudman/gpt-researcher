<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://docs.gptr.dev/blog</id>
    <title>GPT Researcher Blog</title>
    <updated>2025-02-26T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://docs.gptr.dev/blog"/>
    <subtitle>GPT Researcher Blog</subtitle>
    <icon>https://docs.gptr.dev/img/gptr-logo.png</icon>
    <entry>
        <title type="html"><![CDATA[Introducing Deep Research: The Open Source Alternative]]></title>
        <id>Introducing Deep Research: The Open Source Alternative</id>
        <link href="https://docs.gptr.dev/blog/2025/02/26/deep-research"/>
        <updated>2025-02-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Dawn of Deep Research in AI]]></summary>
        <content type="html"><![CDATA[<h2>The Dawn of Deep Research in AI</h2><p>The AI research landscape is witnessing a revolutionary shift with the emergence of &quot;Deep Research&quot; capabilities. But what exactly is deep research, and why should you care? </p><p>Deep research represents the next evolution in AI-powered information retrieval - going far beyond simple search to deliver comprehensive, multi-layered analysis of complex topics. Unlike traditional search engines that return a list of links, or even first-generation AI assistants that provide surface-level summaries, deep research tools deploy sophisticated algorithms to explore topics with unprecedented depth and breadth, mimicking the way human researchers would tackle complex subjects.</p><p>The key features that define true deep research capabilities include iterative analysis that refines queries and results dynamically (<a href="https://www.infoq.com/news/2025/02/perplexity-deep-research/">InfoQ, 2025</a>), multimodal processing that integrates diverse data formats (<a href="https://observer.com/2025/01/openai-google-gemini-agi/">Observer, 2025</a>), real-time data retrieval for up-to-date insights (<a href="https://winbuzzer.com/2025/02/15/perplexity-deep-research-challenges-openai-and-googles-ai-powered-information-retrieval-xcxwbn/">WinBuzzer, 2025</a>), and structured outputs with proper citations for academic and technical applications (<a href="https://www.helicone.ai/blog/openai-deep-research">Helicone, 2025</a>).</p><p>In recent months, we&#x27;ve seen major players launch their own deep research solutions, each with its unique approach and positioning in the market:</p><ul><li><p><strong>Perplexity AI</strong> focuses on speed, delivering research results in under three minutes with real-time data retrieval (<a href="https://www.analyticsvidhya.com/blog/2025/02/perplexity-deep-research/">Analytics Vidhya, 2025</a>). Their cost-effective model (starting at free tier) makes advanced research accessible to a broader audience, though some analysts note potential accuracy trade-offs in favor of speed (<a href="https://medium.com/towards-agi/perplexity-ai-deep-research-vs-openai-deep-research-an-in-depth-comparison-6784c814fc4a">Medium, 2025</a>).</p></li><li><p><strong>OpenAI&#x27;s Deep Research</strong> (built on the O3 model) prioritizes depth and precision, excelling in technical and academic applications with advanced reasoning capabilities (<a href="https://www.helicone.ai/blog/openai-deep-research">Helicone, 2025</a>). Their structured outputs include detailed citations, ensuring reliability and verifiability. However, at $200/month (<a href="https://opentools.ai/news/openai-unveils-groundbreaking-deep-research-chatgpt-for-pro-users">Opentools, 2025</a>), it represents a significant investment, and comprehensive reports can take 5-30 minutes to generate (<a href="https://www.clickittech.com/ai/perplexity-deep-research-vs-openai-deep-research/">ClickItTech, 2025</a>).</p></li><li><p><strong>Google&#x27;s Gemini 2.0</strong> emphasizes multimodal integration across text, images, audio, and video, with particular strength in enterprise applications (<a href="https://blog.adyog.com/2024/12/31/the-ai-titans-face-off-openais-o3-vs-googles-gemini-2-0/">Adyog, 2024</a>). At $20/month, it offers a more affordable alternative to OpenAI&#x27;s solution, though some users note limitations in customization flexibility (<a href="https://www.helicone.ai/blog/openai-deep-research">Helicone, 2025</a>).</p></li></ul><p>What makes deep research truly exciting is its potential to democratize advanced knowledge synthesis (<a href="https://medium.com/@greeshmamshajan/the-evolution-of-ai-powered-research-perplexitys-disruption-and-the-battle-for-cognitive-87af682cc8e6">Medium, 2025</a>), dramatically enhance productivity by automating time-intensive research tasks (<a href="https://www.themobileindian.com/news/perplexity-deep-research-vs-openai-deep-research-vs-gemini-1-5-pro-deep-research-ai-fight">The Mobile Indian, 2025</a>), and open new avenues for interdisciplinary research through advanced reasoning capabilities (<a href="https://observer.com/2025/01/openai-google-gemini-agi/">Observer, 2025</a>).</p><p>However, a key limitation in the current market is accessibility - the most powerful deep research tools remain locked behind expensive paywalls or closed systems, putting them out of reach for many researchers, students, and smaller organizations who could benefit most from these capabilities.</p><h2>Introducing GPT Researcher Deep Research ✨</h2><p>We&#x27;re thrilled to announce our answer to this trend: <strong>GPT Researcher Deep Research</strong> - an advanced open-source recursive research system that explores topics with depth and breadth, all while maintaining cost-effectiveness and transparency.</p><p><a href="https://github.com/assafelovic/gpt-researcher">GPT Researcher</a> Deep Research not only matches the capabilities of the industry giants but exceeds them in several key metrics:</p><ul><li><strong>Cost-effective</strong>: Each deep research operation costs approximately $0.40 (using <code>o3-mini</code> on <code>&quot;high&quot;</code> reasoning effort)</li><li><strong>Time-efficient</strong>: Complete research in around 5 minutes</li><li><strong>Fully customizable</strong>: Adjust parameters to match your specific research needs</li><li><strong>Transparent</strong>: Full visibility into the research process and methodology</li><li><strong>Open source</strong>: Free to use, modify, and integrate into your workflows</li></ul><h2>How It Works: The Recursive Research Tree</h2><p>What makes GPT Researcher&#x27;s deep research so powerful is its tree-like exploration pattern that combines breadth and depth in an intelligent, recursive approach:</p><p><img src="https://github.com/user-attachments/assets/eba2d94b-bef3-4f8d-bbc0-f15bd0a40968" alt="Research Flow Diagram"/></p><ol><li><strong>Breadth Exploration</strong>: At each level, it generates multiple search queries to explore different aspects of your topic</li><li><strong>Depth Diving</strong>: For each branch, it recursively goes deeper, following promising leads and uncovering hidden connections</li><li><strong>Concurrent Processing</strong>: Utilizing async/await patterns to run multiple research paths simultaneously</li><li><strong>Context Management</strong>: Automatically aggregates and synthesizes findings across all branches</li><li><strong>Real-time Tracking</strong>: Provides updates on research progress across both breadth and depth dimensions</li></ol><p>Imagine deploying a team of AI researchers, each following their own research path while collaborating to build a comprehensive understanding of your topic. That&#x27;s the power of GPT Researcher&#x27;s deep research approach.</p><h2>Getting Started in Minutes</h2><p>Integrating deep research into your projects is remarkably straightforward:</p><pre><code class="language-python">from gpt_researcher import GPTResearcher
import asyncio

async def main():
    # Initialize researcher with deep research type
    researcher = GPTResearcher(
        query=&quot;What are the latest developments in quantum computing?&quot;,
        report_type=&quot;deep&quot;,  # This triggers deep research mode
    )
    
    # Run research
    research_data = await researcher.conduct_research()
    
    # Generate report
    report = await researcher.write_report()
    print(report)

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre><h2>Under the Hood: How Deep Research Works</h2><p>Looking at the codebase reveals the sophisticated system that powers GPT Researcher&#x27;s deep research capabilities:</p><h3>1. Query Generation and Planning</h3><p>The system begins by generating a set of diverse search queries based on your initial question:</p><pre><code class="language-python">async def generate_search_queries(self, query: str, num_queries: int = 3) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate SERP queries for research&quot;&quot;&quot;
    messages = [
        {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are an expert researcher generating search queries.&quot;},
        {&quot;role&quot;: &quot;user&quot;,
         &quot;content&quot;: f&quot;Given the following prompt, generate {num_queries} unique search queries to research the topic thoroughly. For each query, provide a research goal. Format as &#x27;Query: &lt;query&gt;&#x27; followed by &#x27;Goal: &lt;goal&gt;&#x27; for each pair: {query}&quot;}
    ]
</code></pre><p>This process creates targeted queries, each with a specific research goal. For example, a query about quantum computing might generate:</p><ul><li>&quot;Latest quantum computing breakthroughs 2024-2025&quot;</li><li>&quot;Quantum computing practical applications in finance&quot;</li><li>&quot;Quantum error correction advancements&quot;</li></ul><h3>2. Concurrent Research Execution</h3><p>The system then executes these queries concurrently, with intelligent resource management:</p><pre><code class="language-python"># Process queries with concurrency limit
semaphore = asyncio.Semaphore(self.concurrency_limit)

async def process_query(serp_query: Dict[str, str]) -&gt; Optional[Dict[str, Any]]:
    async with semaphore:
        # Research execution logic
</code></pre><p>This approach maximizes efficiency while ensuring system stability - like having multiple researchers working in parallel.</p><h3>3. Recursive Exploration</h3><p>The magic happens with recursive exploration:</p><pre><code class="language-python"># Continue deeper if needed
if depth &gt; 1:
    new_breadth = max(2, breadth // 2)
    new_depth = depth - 1
    progress.current_depth += 1

    # Create next query from research goal and follow-up questions
    next_query = f&quot;&quot;&quot;
    Previous research goal: {result[&#x27;researchGoal&#x27;]}
    Follow-up questions: {&#x27; &#x27;.join(result[&#x27;followUpQuestions&#x27;])}
    &quot;&quot;&quot;

    # Recursive research
    deeper_results = await self.deep_research(
        query=next_query,
        breadth=new_breadth,
        depth=new_depth,
        # Additional parameters
    )
</code></pre><p>This creates a tree-like exploration pattern that follows promising leads deeper while maintaining breadth of coverage.</p><h3>4. Context Management and Synthesis</h3><p>Managing the vast amount of gathered information requires sophisticated tracking:</p><pre><code class="language-python"># Trim context to stay within word limits
trimmed_context = trim_context_to_word_limit(all_context)
logger.info(f&quot;Trimmed context from {len(all_context)} items to {len(trimmed_context)} items to stay within word limit&quot;)
</code></pre><p>This ensures the most relevant information is retained while respecting model context limitations.</p><h2>Customizing Your Research Experience</h2><p>One of the key advantages of GPT Researcher&#x27;s open-source approach is full customizability. You can tailor the research process to your specific needs through several configuration options:</p><pre><code class="language-yaml">deep_research_breadth: 4    # Number of parallel research paths
deep_research_depth: 2      # How many levels deep to explore
deep_research_concurrency: 4  # Maximum concurrent operations
total_words: 2500           # Word count for final report
</code></pre><p>Apply these configurations through environment variables, a config file, or directly in code:</p><pre><code class="language-python">researcher = GPTResearcher(
    query=&quot;your query&quot;,
    report_type=&quot;deep&quot;,
    config_path=&quot;path/to/config.yaml&quot;
)
</code></pre><h2>Real-time Progress Tracking</h2><p>For applications requiring visibility into the research process, GPT Researcher provides detailed progress tracking:</p><pre><code class="language-python">class ResearchProgress:
    current_depth: int       # Current depth level
    total_depth: int         # Maximum depth to explore
    current_breadth: int     # Current number of parallel paths
    total_breadth: int       # Maximum breadth at each level
    current_query: str       # Currently processing query
    completed_queries: int   # Number of completed queries
    total_queries: int       # Total queries to process
</code></pre><p>This allows you to build interfaces that show research progress in real-time - perfect for applications where users want visibility into the process.</p><h2>Why This Matters: The Impact of Deep Research</h2><p>The democratization of deep research capabilities through open-source tools like GPT Researcher represents a paradigm shift in how we process and analyze information. Benefits include:</p><ol><li><strong>Deeper insights</strong>: Uncover connections and patterns that surface-level research would miss</li><li><strong>Time savings</strong>: Automate hours or days of manual research into minutes</li><li><strong>Reduced costs</strong>: Enterprise-grade research capabilities at a fraction of the cost</li><li><strong>Accessibility</strong>: Bringing advanced research tools to individuals and small organizations</li><li><strong>Transparency</strong>: Full visibility into the research methodology and sources</li></ol><h2>Getting Started Today</h2><p>Ready to experience the power of deep research in your projects? Here&#x27;s how to get started:</p><ol><li><strong>Installation</strong>: <code>pip install gpt-researcher</code></li><li><strong>API Key</strong>: Set up your API key for the LLM provider and search engine of your choice</li><li><strong>Configuration</strong>: Customize parameters based on your research needs</li><li><strong>Implementation</strong>: Use the example code to integrate into your application</li></ol><p>More detailed instructions and examples can be found in the <a href="https://docs.gptr.dev/docs/gpt-researcher/gptr/deep_research">GPT Researcher documentation</a></p><p>Whether you&#x27;re a developer building the next generation of research tools, an academic seeking deeper insights, or a business professional needing comprehensive analysis, GPT Researcher&#x27;s deep research capabilities offer an accessible, powerful solution that rivals - and in many ways exceeds - the offerings from major AI companies.</p><p>The future of AI-powered research is here, and it&#x27;s open source. 🎉</p><p>Happy researching!</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Future of Research is Hybrid]]></title>
        <id>gptr-hybrid</id>
        <link href="https://docs.gptr.dev/blog/gptr-hybrid"/>
        <updated>2024-09-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Hyrbrid Research with GPT Researcher]]></summary>
        <content type="html"><![CDATA[<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*MaauY1ecsD05nL8JqW0Zdg.jpeg" alt="Hyrbrid Research with GPT Researcher"/></p><p>Over the past few years, we&#x27;ve seen an explosion of new AI tools designed to disrupt research. Some, like <a href="https://www.chatpdf.com/">ChatPDF</a> and <a href="https://consensus.app">Consensus</a>, focus on extracting insights from documents. Others, such as <a href="https://www.perplexity.ai/">Perplexity</a>, excel at scouring the web for information. But here&#x27;s the thing: none of these tools combine both web and local document search within a single contextual research pipeline.</p><p>This is why I&#x27;m excited to introduce the latest advancements of <strong><a href="https://gptr.dev">GPT Researcher</a></strong> — now able to conduct hybrid research on any given task and documents.</p><p>Web driven research often lacks specific context, risks information overload, and may include outdated or unreliable data. On the flip side, local driven research is limited to historical data and existing knowledge, potentially creating organizational echo chambers and missing out on crucial market trends or competitor moves. Both approaches, when used in isolation, can lead to incomplete or biased insights, hampering your ability to make fully informed decisions.</p><p>Today, we&#x27;re going to change the game. By the end of this guide, you&#x27;ll learn how to conduct hybrid research that combines the best of both worlds — web and local — enabling you to conduct more thorough, relevant, and insightful research.</p><h2>Why Hybrid Research Works Better</h2><p>By combining web and local sources, hybrid research addresses these limitations and offers several key advantages:</p><ol><li><p><strong>Grounded context</strong>: Local documents provide a foundation of verified, organization specific information. This grounds the research in established knowledge, reducing the risk of straying from core concepts or misinterpreting industry specific terminology.</p><p><em>Example</em>: A pharmaceutical company researching a new drug development opportunity can use its internal research papers and clinical trial data as a base, then supplement this with the latest published studies and regulatory updates from the web.</p></li><li><p><strong>Enhanced accuracy</strong>: Web sources offer up-to-date information, while local documents provide historical context. This combination allows for more accurate trend analysis and decision-making.</p><p><em>Example</em>: A financial services firm analyzing market trends can combine their historical trading data with real-time market news and social media sentiment analysis to make more informed investment decisions.</p></li><li><p><strong>Reduced bias</strong>: By drawing from both web and local sources, we mitigate the risk of bias that might be present in either source alone.</p><p><em>Example</em>: A tech company evaluating its product roadmap can balance internal feature requests and usage data with external customer reviews and competitor analysis, ensuring a well-rounded perspective.</p></li><li><p><strong>Improved planning and reasoning</strong>: LLMs can leverage the context from local documents to better plan their web research strategies and reason about the information they find online.</p><p><em>Example</em>: An AI-powered market research tool can use a company&#x27;s past campaign data to guide its web search for current marketing trends, resulting in more relevant and actionable insights.</p></li><li><p><strong>Customized insights</strong>: Hybrid research allows for the integration of proprietary information with public data, leading to unique, organization-specific insights.</p><p><em>Example</em>: A retail chain can combine its sales data with web-scraped competitor pricing and economic indicators to optimize its pricing strategy in different regions.</p></li></ol><p>These are just a few examples for business use cases that can leverage hybrid research, but enough with the small talk — let&#x27;s build!</p><h2>Building the Hybrid Research Assistant</h2><p>Before we dive into the details, it&#x27;s worth noting that GPT Researcher has the capability to conduct hybrid research out of the box! However, to truly appreciate how this works and to give you a deeper understanding of the process, we&#x27;re going to take a look under the hood.</p><p><img src="./gptr-hybrid.png" alt="GPT Researcher hybrid research"/></p><p>GPT Researcher conducts web research based on an auto-generated plan from local documents, as seen in the architecture above. It then retrieves relevant information from both local and web data for the final research report.</p><p>We&#x27;ll explore how local documents are processed using LangChain, which is a key component of GPT Researcher&#x27;s document handling. Then, we&#x27;ll show you how to leverage GPT Researcher to conduct hybrid research, combining the advantages of web search with your local document knowledge base.</p><h3>Processing Local Documents with Langchain</h3><p>LangChain provides a variety of document loaders that allow us to process different file types. This flexibility is crucial when dealing with diverse local documents. Here&#x27;s how to set it up:</p><pre><code class="language-python">from langchain_community.document_loaders import (
    PyMuPDFLoader, 
    TextLoader, 
    UnstructuredCSVLoader, 
    UnstructuredExcelLoader,
    UnstructuredMarkdownLoader, 
    UnstructuredPowerPointLoader,
    UnstructuredWordDocumentLoader
)
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma

def load_local_documents(file_paths):
    documents = []
    for file_path in file_paths:
        if file_path.endswith(&#x27;.pdf&#x27;):
            loader = PyMuPDFLoader(file_path)
        elif file_path.endswith(&#x27;.txt&#x27;):
            loader = TextLoader(file_path)
        elif file_path.endswith(&#x27;.csv&#x27;):
            loader = UnstructuredCSVLoader(file_path)
        elif file_path.endswith(&#x27;.xlsx&#x27;):
            loader = UnstructuredExcelLoader(file_path)
        elif file_path.endswith(&#x27;.md&#x27;):
            loader = UnstructuredMarkdownLoader(file_path)
        elif file_path.endswith(&#x27;.pptx&#x27;):
            loader = UnstructuredPowerPointLoader(file_path)
        elif file_path.endswith(&#x27;.docx&#x27;):
            loader = UnstructuredWordDocumentLoader(file_path)
        else:
            raise ValueError(f&quot;Unsupported file type: {file_path}&quot;)
        
        documents.extend(loader.load())
    
    return documents

# Use the function to load your local documents
local_docs = load_local_documents([&#x27;company_report.pdf&#x27;, &#x27;meeting_notes.docx&#x27;, &#x27;data.csv&#x27;])

# Split the documents into smaller chunks for more efficient processing
text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
splits = text_splitter.split_documents(local_docs)

# Create embeddings and store them in a vector database for quick retrieval
embeddings = OpenAIEmbeddings()
vectorstore = Chroma.from_documents(documents=splits, embedding=embeddings)

# Example of how to perform a similarity search
query = &quot;What were the key points from our last strategy meeting?&quot;
relevant_docs = vectorstore.similarity_search(query, k=3)

for doc in relevant_docs:
    print(doc.page_content)
</code></pre><h3>Conducting Web Research with GPT Researcher</h3><p>Now that we&#x27;ve learned how to work with local documents, let&#x27;s take a quick look at how GPT Researcher works under the hood:</p><p><img src="https://miro.medium.com/v2/resize:fit:1400/1*yFtT43N0GxL0TMKvjtYjug.png" alt="GPT Researcher Architecture"/></p><p>As seen above, GPT Researcher creates a research plan based on the given task by generating potential research queries that can collectively provide an objective and broad overview of the topic. Once these queries are generated, GPT Researcher uses a search engine like Tavily to find relevant results. Each scraped result is then saved in a vector database. Finally, the top k chunks most related to the research task are retrieved to generate a final research report.</p><p>GPT Researcher supports hybrid research, which involves an additional step of chunking local documents (implemented using Langchain) before retrieving the most related information. After numerous evaluations conducted by the community, we&#x27;ve found that hybrid research improved the correctness of final results by over 40%!</p><h3>Running the Hybrid Research with GPT Researcher</h3><p>Now that you have a better understanding of how hybrid research works, let&#x27;s demonstrate how easy this can be achieved with GPT Researcher.</p><h4>Step 1: Install GPT Researcher with PIP</h4><pre><code class="language-bash">pip install gpt-researcher
</code></pre><h4>Step 2: Setting up the environment</h4><p>We will run GPT Researcher with OpenAI as the LLM vendor and Tavily as the search engine. You&#x27;ll need to obtain API keys for both before moving forward. Then, export the environment variables in your CLI as follows:</p><pre><code class="language-bash">export OPENAI_API_KEY={your-openai-key}
export TAVILY_API_KEY={your-tavily-key}
</code></pre><h4>Step 3: Initialize GPT Researcher with hybrid research configuration</h4><p>GPT Researcher can be easily initialized with params that signal it to run a hybrid research. You can conduct many forms of research, head to the documentation page to learn more.</p><p>To get GPT Researcher to run a hybrid research, you need to include all relevant files in my-docs directory (create it if it doesn&#x27;t exist), and set the instance report_source to &quot;hybrid&quot; as seen below. Once the report source is set to hybrid, GPT Researcher will look for existing documents in the my-docs directory and include them in the research. If no documents exist, it will ignore it.</p><pre><code class="language-python">from gpt_researcher import GPTResearcher
import asyncio

async def get_research_report(query: str, report_type: str, report_source: str) -&gt; str:
    researcher = GPTResearcher(query=query, report_type=report_type, report_source=report_source)
    research = await researcher.conduct_research()
    report = await researcher.write_report()
    return report
    
if __name__ == &quot;__main__&quot;:
    query = &quot;How does our product roadmap compare to emerging market trends in our industry?&quot;
    report_source = &quot;hybrid&quot;

    report = asyncio.run(get_research_report(query=query, report_type=&quot;research_report&quot;, report_source=report_source))
    print(report)
</code></pre><p>As seen above, we can run the research on the following example:</p><ul><li>Research task: &quot;How does our product roadmap compare to emerging market trends in our industry?&quot;</li><li>Web: Current market trends, competitor announcements, and industry forecasts</li><li>Local: Internal product roadmap documents and feature prioritization lists</li></ul><p>After various community evaluations we&#x27;ve found that the results of this research improve quality and correctness of research by over 40% and remove hallucinations by 50%. Moreover as stated above, local information helps the LLM improve planning reasoning allowing it to make better decisions and researching more relevant web sources.</p><p>But wait, there&#x27;s more! GPT Researcher also includes a sleek front-end app using NextJS and Tailwind. To learn how to get it running check out the documentation page. You can easily use drag and drop for documents to run hybrid research.</p><h2>Conclusion</h2><p>Hybrid research represents a significant advancement in data gathering and decision making. By leveraging tools like <a href="https://gptr.dev">GPT Researcher</a>, teams can now conduct more comprehensive, context-aware, and actionable research. This approach addresses the limitations of using web or local sources in isolation, offering benefits such as grounded context, enhanced accuracy, reduced bias, improved planning and reasoning, and customized insights.</p><p>The automation of hybrid research can enable teams to make faster, more data-driven decisions, ultimately enhancing productivity and offering a competitive advantage in analyzing an expanding pool of unstructured and dynamic information.</p>]]></content>
        <author>
            <name>Assaf Elovic</name>
            <uri>https://github.com/assafelovic</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Build the Ultimate Research Multi-Agent Assistant]]></title>
        <id>gptr-langgraph</id>
        <link href="https://docs.gptr.dev/blog/gptr-langgraph"/>
        <updated>2024-05-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Header]]></summary>
        <content type="html"><![CDATA[<p><img src="./blog-langgraph.jpeg" alt="Header"/></p><h1>Introducing the GPT Researcher Multi-Agent Assistant</h1><h3>Learn how to build an autonomous research assistant using LangGraph with a team of specialized AI agents</h3><p>It has only been a year since the initial release of GPT Researcher, but methods for building, testing, and deploying AI agents have already evolved significantly. That’s just the nature and speed of the current AI progress. What started as simple zero-shot or few-shot prompting, has quickly evolved to agent function calling, RAG and now finally agentic workflows (aka “flow engineering”).</p><p>Andrew Ng has <a href="https://www.deeplearning.ai/the-batch/how-agents-can-improve-llm-performance/">recently stated</a>, “I think AI agent workflows will drive massive AI progress this year — perhaps even more than the next generation of foundation models. This is an important trend, and I urge everyone who works in AI to pay attention to it.”</p><p>In this article you will learn why multi-agent workflows are the current best standard and how to build the optimal autonomous research multi-agent assistant using LangGraph.</p><p>To skip this tutorial, feel free to check out the Github repo of <a href="https://github.com/assafelovic/gpt-researcher/tree/master/multi_agents">GPT Researcher x LangGraph</a>.</p><h2>Introducing LangGraph</h2><p>LangGraph is an extension of LangChain aimed at creating agent and multi-agent flows. It adds in the ability to create cyclical flows and comes with memory built in — both important attributes for creating agents.</p><p>LangGraph provides developers with a high degree of controllability and is important for creating custom agents and flows. Nearly all agents in production are customized towards the specific use case they are trying solve. LangGraph gives you the flexibility to create arbitrary customized agents, while providing an intuitive developer experience for doing so.</p><p>Enough with the smalltalk, let’s start building!</p><h2>Building the Ultimate Autonomous Research Agent</h2><p>By leveraging LangGraph, the research process can be significantly improved in depth and quality by leveraging multiple agents with specialized skills. Having every agent focus and specialize only a specific skill, allows for better separation of concerns, customizability, and further development at scale as the project grows.</p><p>Inspired by the recent STORM paper, this example showcases how a team of AI agents can work together to conduct research on a given topic, from planning to publication. This example will also leverage the leading autonomous research agent GPT Researcher.</p><h3>The Research Agent Team</h3><p>The research team consists of seven LLM agents:</p><ul><li><strong>Chief Editor</strong> — Oversees the research process and manages the team. This is the “master” agent that coordinates the other agents using LangGraph. This agent acts as the main LangGraph interface.</li><li><strong>GPT Researcher</strong> — A specialized autonomous agent that conducts in depth research on a given topic.</li><li><strong>Editor</strong> — Responsible for planning the research outline and structure.</li><li><strong>Reviewer</strong> — Validates the correctness of the research results given a set of criteria.</li><li><strong>Reviser</strong> — Revises the research results based on the feedback from the reviewer.</li><li><strong>Writer</strong> — Responsible for compiling and writing the final report.</li><li><strong>Publisher</strong> — Responsible for publishing the final report in various formats.</li></ul><h3>Architecture</h3><p>As seen below, the automation process is based on the following stages: Planning the research, data collection and analysis, review and revision, writing the report and finally publication:</p><p><img src="./architecture.jpeg" alt="Architecture"/></p><p>More specifically the process is as follows:</p><ul><li><p><strong>Browser (gpt-researcher)</strong> — Browses the internet for initial research based on the given research task. This step is crucial for LLMs to plan the research process based on up to date and relevant information, and not rely solely on pre-trained data for a given task or topic.</p></li><li><p><strong>Editor</strong> — Plans the report outline and structure based on the initial research. The Editor is also responsible for triggering the parallel research tasks based on the planned outline.</p></li><li><p>For each outline topic (in parallel):</p><ul><li><strong>Researcher (gpt-researcher)</strong> — Runs an in depth research on the subtopics and writes a draft. This agent leverages the GPT Researcher Python package under the hood, for optimized, in depth and factual research report.</li><li><strong>Reviewer</strong> — Validates the correctness of the draft given a set of guidelines and provides feedback to the reviser (if any).</li><li><strong>Reviser</strong> — Revises the draft until it is satisfactory based on the reviewer feedback.</li></ul></li><li><p><strong>Writer</strong> — Compiles and writes the final report including an introduction, conclusion and references section from the given research findings.</p></li><li><p><strong>Publisher</strong> — Publishes the final report to multi formats such as PDF, Docx, Markdown, etc.</p></li><li><p>We will not dive into all the code since there’s a lot of it, but focus mostly on the interesting parts I’ve found valuable to share.</p></li></ul><h2>Define the Graph State</h2><p>One of my favorite features with LangGraph is state management. States in LangGraph are facilitated through a structured approach where developers define a GraphState that encapsulates the entire state of the application. Each node in the graph can modify this state, allowing for dynamic responses based on the evolving context of the interaction.</p><p>Like in every start of a technical design, considering the data schema throughout the application is key. In this case we’ll define a ResearchState like so:</p><pre><code class="language-python">class ResearchState(TypedDict):
    task: dict
    initial_research: str
    sections: List[str]
    research_data: List[dict]
    # Report layout
    title: str
    headers: dict
    date: str
    table_of_contents: str
    introduction: str
    conclusion: str
    sources: List[str]
    report: str
</code></pre><p>As seen above, the state is divided into two main areas: the research task and the report layout content. As data circulates through the graph agents, each agent will, in turn, generate new data based on the existing state and update it for subsequent processing further down the graph with other agents.</p><p>We can then initialize the graph with the following:</p><pre><code class="language-python">from langgraph.graph import StateGraph
workflow = StateGraph(ResearchState)
</code></pre><p>Initializing the graph with LangGraph
As stated above, one of the great things about multi-agent development is building each agent to have specialized and scoped skills. Let’s take an example of the Researcher agent using GPT Researcher python package:</p><pre><code class="language-python">from gpt_researcher import GPTResearcher

class ResearchAgent:
    def __init__(self):
        pass
  
    async def research(self, query: str):
        # Initialize the researcher
        researcher = GPTResearcher(parent_query=parent_query, query=query, report_type=research_report, config_path=None)
        # Conduct research on the given query
        await researcher.conduct_research()
        # Write the report
        report = await researcher.write_report()
  
        return report
</code></pre><p>As you can see above, we’ve created an instance of the Research agent. Now let’s assume we’ve done the same for each of the team’s agent. After creating all of the agents, we’d initialize the graph with LangGraph:</p><pre><code class="language-python">def init_research_team(self):
    # Initialize skills
    editor_agent = EditorAgent(self.task)
    research_agent = ResearchAgent()
    writer_agent = WriterAgent()
    publisher_agent = PublisherAgent(self.output_dir)
    
    # Define a Langchain StateGraph with the ResearchState
    workflow = StateGraph(ResearchState)
    
    # Add nodes for each agent
    workflow.add_node(&quot;browser&quot;, research_agent.run_initial_research)
    workflow.add_node(&quot;planner&quot;, editor_agent.plan_research)
    workflow.add_node(&quot;researcher&quot;, editor_agent.run_parallel_research)
    workflow.add_node(&quot;writer&quot;, writer_agent.run)
    workflow.add_node(&quot;publisher&quot;, publisher_agent.run)
    
    workflow.add_edge(&#x27;browser&#x27;, &#x27;planner&#x27;)
    workflow.add_edge(&#x27;planner&#x27;, &#x27;researcher&#x27;)
    workflow.add_edge(&#x27;researcher&#x27;, &#x27;writer&#x27;)
    workflow.add_edge(&#x27;writer&#x27;, &#x27;publisher&#x27;)
    
    # set up start and end nodes
    workflow.set_entry_point(&quot;browser&quot;)
    workflow.add_edge(&#x27;publisher&#x27;, END)
    
    return workflow
</code></pre><p>As seen above, creating the LangGraph graph is very straight forward and consists of three main functions: add_node, add_edge and set_entry_point. With these main functions you can first add the nodes to the graph, connect the edges and finally set the starting point.</p><p>Focus check: If you’ve been following the code and architecture properly, you’ll notice that the Reviewer and Reviser agents are missing in the initialization above. Let’s dive into it!</p><h2>A Graph within a Graph to support stateful Parallelization</h2><p>This was the most exciting part of my experience working with LangGraph! One exciting feature of this autonomous assistant is having a parallel run for each research task, that would be reviewed and revised based on a set of predefined guidelines.</p><p>Knowing how to leverage parallel work within a process is key for optimizing speed. But how would you trigger parallel agent work if all agents report to the same state? This can cause race conditions and inconsistencies in the final data report. To solve this, you can create a sub graph, that would be triggered from the main LangGraph instance. This sub graph would hold its own state for each parallel run, and that would solve the issues that were raised.</p><p>As we’ve done before, let’s define the LangGraph state and its agents. Since this sub graph basically reviews and revises a research draft, we’ll define the state with draft information:</p><pre><code class="language-python">class DraftState(TypedDict):
    task: dict
    topic: str
    draft: dict
    review: str
    revision_notes: str
</code></pre><p>As seen in the DraftState, we mostly care about the topic discussed, and the reviewer and revision notes as they communicate between each other to finalize the subtopic research report. To create the circular condition we’ll take advantage of the last important piece of LangGraph which is conditional edges:</p><pre><code class="language-python">async def run_parallel_research(self, research_state: dict):
    workflow = StateGraph(DraftState)
    
    workflow.add_node(&quot;researcher&quot;, research_agent.run_depth_research)
    workflow.add_node(&quot;reviewer&quot;, reviewer_agent.run)
    workflow.add_node(&quot;reviser&quot;, reviser_agent.run)
    
    # set up edges researcher-&gt;reviewer-&gt;reviser-&gt;reviewer...
    workflow.set_entry_point(&quot;researcher&quot;)
    workflow.add_edge(&#x27;researcher&#x27;, &#x27;reviewer&#x27;)
    workflow.add_edge(&#x27;reviser&#x27;, &#x27;reviewer&#x27;)
    workflow.add_conditional_edges(&#x27;reviewer&#x27;,
                                   (lambda draft: &quot;accept&quot; if draft[&#x27;review&#x27;] is None else &quot;revise&quot;),
                                   {&quot;accept&quot;: END, &quot;revise&quot;: &quot;reviser&quot;})
</code></pre><p>By defining the conditional edges, the graph would direct to reviser if there exists review notes by the reviewer, or the cycle would end with the final draft. If you go back to the main graph we’ve built, you’ll see that this parallel work is under a node named “researcher” called by ChiefEditor agent.</p><p>Running the Research Assistant
After finalizing the agents, states and graphs, it’s time to run our research assistant! To make it easier to customize, the assistant runs with a given task.json file:</p><pre><code class="language-json">{
  &quot;query&quot;: &quot;Is AI in a hype cycle?&quot;,
  &quot;max_sections&quot;: 3,
  &quot;publish_formats&quot;: {
    &quot;markdown&quot;: true,
    &quot;pdf&quot;: true,
    &quot;docx&quot;: true
  },
  &quot;follow_guidelines&quot;: false,
  &quot;model&quot;: &quot;gpt-4-turbo&quot;,
  &quot;guidelines&quot;: [
    &quot;The report MUST be written in APA format&quot;,
    &quot;Each sub section MUST include supporting sources using hyperlinks. If none exist, erase the sub section or rewrite it to be a part of the previous section&quot;,
    &quot;The report MUST be written in spanish&quot;
  ]
}
</code></pre><p>The task object is pretty self explanatory, however please notice that follow_guidelines if false would cause the graph to ignore the revision step and defined guidelines. Also, the max_sections field defines how many subheaders to research for. Having less will generate a shorter report.</p><p>Running the assistant will result in a final research report in formats such as Markdown, PDF and Docx.</p><p>To download and run the example check out the GPT Researcher x LangGraph <a href="https://github.com/assafelovic/gpt-researcher/tree/master/multi_agents">open source page</a>.</p><h2>What’s Next?</h2><p>Going forward, there are super exciting things to think about. Human in the loop is key for optimized AI experiences. Having a human help the assistant revise and focus on just the right research plan, topics and outline, would enhance the overall quality and experience. Also generally, aiming for relying on human intervention throughout the AI flow ensures correctness, sense of control and deterministic results. Happy to see that LangGraph already supports this out of the box as seen here.</p><p>In addition, having support for research about both web and local data would be key for many types of business and personal use cases.</p><p>Lastly, more efforts can be done to improve the quality of retrieved sources and making sure the final report is built in the optimal storyline.</p><p>A step forward in LangGraph and multi-agent collaboration in a whole would be where assistants can plan and generate graphs dynamically based on given tasks. This vision would allow assistants to choose only a subset of agents for a given task and plan their strategy based on the graph fundamentals as presented in this article and open a whole new world of possibilities. Given the pace of innovation in the AI space, it won’t be long before a new disruptive version of GPT Researcher is launched. Looking forward to what the future brings!</p><p>To keep track of this project’s ongoing progress and updates please join our Discord community. And as always, if you have any feedback or further questions, please comment below!</p>]]></content>
        <author>
            <name>Assaf Elovic</name>
            <uri>https://github.com/assafelovic</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to build an OpenAI Assistant with Internet access]]></title>
        <id>building-openai-assistant</id>
        <link href="https://docs.gptr.dev/blog/building-openai-assistant"/>
        <updated>2023-11-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[OpenAI has done it again with a groundbreaking DevDay showcasing some of the latest improvements to the OpenAI suite of tools, products and services. One major release was the new Assistants API that makes it easier for developers to build their own assistive AI apps that have goals and can call models and tools.]]></summary>
        <content type="html"><![CDATA[<p>OpenAI has done it again with a <a href="https://openai.com/blog/new-models-and-developer-products-announced-at-devday">groundbreaking DevDay</a> showcasing some of the latest improvements to the OpenAI suite of tools, products and services. One major release was the new <a href="https://platform.openai.com/docs/assistants/overview">Assistants API</a> that makes it easier for developers to build their own assistive AI apps that have goals and can call models and tools.</p><p>The new Assistants API currently supports three types of tools: Code Interpreter, Retrieval, and Function calling. Although you might expect the Retrieval tool to support online information retrieval (such as search APIs or as ChatGPT plugins), it only supports raw data for now such as text or CSV files.</p><p>This blog will demonstrate how to leverage the latest Assistants API with online information using the function calling tool.</p><p>To skip the tutorial below, feel free to check out the full <a href="https://gist.github.com/assafelovic/579822cd42d52d80db1e1c1ff82ffffd">Github Gist here</a>.</p><p>At a high level, a typical integration of the Assistants API has the following steps:</p><ul><li>Create an <a href="https://platform.openai.com/docs/api-reference/assistants/createAssistant">Assistant</a> in the API by defining its custom instructions and picking a model. If helpful, enable tools like Code Interpreter, Retrieval, and Function calling.</li><li>Create a <a href="https://platform.openai.com/docs/api-reference/threads">Thread</a> when a user starts a conversation.</li><li>Add <a href="https://platform.openai.com/docs/api-reference/messages">Messages</a> to the Thread as the user ask questions.</li><li><a href="https://platform.openai.com/docs/api-reference/runs">Run</a> the Assistant on the Thread to trigger responses. This automatically calls the relevant tools.</li></ul><p>As you can see below, an Assistant object includes Threads for storing and handling conversation sessions between the assistant and users, and Run for invocation of an Assistant on a Thread.</p><p><img src="./diagram-assistant.jpeg" alt="OpenAI Assistant Object"/></p><p>Let’s go ahead and implement these steps one by one! For the example, we will build a finance GPT that can provide insights about financial questions. We will use the <a href="https://github.com/openai/openai-python/tree/main#installation">OpenAI Python SDK v1.2</a> and <a href="https://tavily.com">Tavily Search API</a>.</p><p>First things first, let’s define the assistant’s instructions:</p><pre><code class="language-python">assistant_prompt_instruction = &quot;&quot;&quot;You are a finance expert. 
Your goal is to provide answers based on information from the internet. 
You must use the provided Tavily search API function to find relevant online information. 
You should never use your own knowledge to answer questions.
Please include relevant url sources in the end of your answers.
&quot;&quot;&quot;
</code></pre><p>Next, let’s finalize step 1 and create an assistant using the latest <a href="https://github.com/openai/openai-python/tree/main#installation">GPT-4 Turbo model</a> (128K context), and the call function using the <a href="https://tavily.com/">Tavily web search API</a>:</p><pre><code class="language-python"># Create an assistant
assistant = client.beta.assistants.create(
    instructions=assistant_prompt_instruction,
    model=&quot;gpt-4-1106-preview&quot;,
    tools=[{
        &quot;type&quot;: &quot;function&quot;,
        &quot;function&quot;: {
            &quot;name&quot;: &quot;tavily_search&quot;,
            &quot;description&quot;: &quot;Get information on recent events from the web.&quot;,
            &quot;parameters&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;properties&quot;: {
                    &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The search query to use. For example: &#x27;Latest news on Nvidia stock performance&#x27;&quot;},
                },
                &quot;required&quot;: [&quot;query&quot;]
            }
        }
    }]
)
</code></pre><p>Step 2+3 are quite straight forward, we’ll initiate a new thread and update it with a user message:</p><pre><code class="language-python">thread = client.beta.threads.create()
user_input = input(&quot;You: &quot;)
message = client.beta.threads.messages.create(
    thread_id=thread.id,
    role=&quot;user&quot;,
    content=user_input,
)
</code></pre><p>Finally, we’ll run the assistant on the thread to trigger the function call and get the response:</p><pre><code class="language-python">run = client.beta.threads.runs.create(
    thread_id=thread.id,
    assistant_id=assistant_id,
)
</code></pre><p>So far so good! But this is where it gets a bit messy. Unlike with the regular GPT APIs, the Assistants API doesn’t return a synchronous response, but returns a status. This allows for asynchronous operations across assistants, but requires more overhead for fetching statuses and dealing with each manually.</p><p><img src="./diagram-1.png" alt="Status Diagram"/></p><p>To manage this status lifecycle, let’s build a function that can be reused and handles waiting for various statuses (such as ‘requires_action’):</p><pre><code class="language-python"># Function to wait for a run to complete
def wait_for_run_completion(thread_id, run_id):
    while True:
        time.sleep(1)
        run = client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run_id)
        print(f&quot;Current run status: {run.status}&quot;)
        if run.status in [&#x27;completed&#x27;, &#x27;failed&#x27;, &#x27;requires_action&#x27;]:
            return run
</code></pre><p>This function will sleep as long as the run has not been finalized such as in cases where it’s completed or requires an action from a function call.</p><p>We’re almost there! Lastly, let’s take care of when the assistant wants to call the web search API:</p><pre><code class="language-python"># Function to handle tool output submission
def submit_tool_outputs(thread_id, run_id, tools_to_call):
    tool_output_array = []
    for tool in tools_to_call:
        output = None
        tool_call_id = tool.id
        function_name = tool.function.name
        function_args = tool.function.arguments

        if function_name == &quot;tavily_search&quot;:
            output = tavily_search(query=json.loads(function_args)[&quot;query&quot;])

        if output:
            tool_output_array.append({&quot;tool_call_id&quot;: tool_call_id, &quot;output&quot;: output})

    return client.beta.threads.runs.submit_tool_outputs(
        thread_id=thread_id,
        run_id=run_id,
        tool_outputs=tool_output_array
    )
</code></pre><p>As seen above, if the assistant has reasoned that a function call should trigger, we extract the given required function params and pass back to the runnable thread. We catch this status and call our functions as seen below:</p><pre><code class="language-python">if run.status == &#x27;requires_action&#x27;:
    run = submit_tool_outputs(thread.id, run.id, run.required_action.submit_tool_outputs.tool_calls)
    run = wait_for_run_completion(thread.id, run.id)
</code></pre><p>That’s it! We now have a working OpenAI Assistant that can be used to answer financial questions using real time online information. Below is the full runnable code:</p><pre><code class="language-python">import os
import json
import time
from openai import OpenAI
from tavily import TavilyClient

# Initialize clients with API keys
client = OpenAI(api_key=os.environ[&quot;OPENAI_API_KEY&quot;])
tavily_client = TavilyClient(api_key=os.environ[&quot;TAVILY_API_KEY&quot;])

assistant_prompt_instruction = &quot;&quot;&quot;You are a finance expert. 
Your goal is to provide answers based on information from the internet. 
You must use the provided Tavily search API function to find relevant online information. 
You should never use your own knowledge to answer questions.
Please include relevant url sources in the end of your answers.
&quot;&quot;&quot;

# Function to perform a Tavily search
def tavily_search(query):
    search_result = tavily_client.get_search_context(query, search_depth=&quot;advanced&quot;, max_tokens=8000)
    return search_result

# Function to wait for a run to complete
def wait_for_run_completion(thread_id, run_id):
    while True:
        time.sleep(1)
        run = client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run_id)
        print(f&quot;Current run status: {run.status}&quot;)
        if run.status in [&#x27;completed&#x27;, &#x27;failed&#x27;, &#x27;requires_action&#x27;]:
            return run

# Function to handle tool output submission
def submit_tool_outputs(thread_id, run_id, tools_to_call):
    tool_output_array = []
    for tool in tools_to_call:
        output = None
        tool_call_id = tool.id
        function_name = tool.function.name
        function_args = tool.function.arguments

        if function_name == &quot;tavily_search&quot;:
            output = tavily_search(query=json.loads(function_args)[&quot;query&quot;])

        if output:
            tool_output_array.append({&quot;tool_call_id&quot;: tool_call_id, &quot;output&quot;: output})

    return client.beta.threads.runs.submit_tool_outputs(
        thread_id=thread_id,
        run_id=run_id,
        tool_outputs=tool_output_array
    )

# Function to print messages from a thread
def print_messages_from_thread(thread_id):
    messages = client.beta.threads.messages.list(thread_id=thread_id)
    for msg in messages:
        print(f&quot;{msg.role}: {msg.content[0].text.value}&quot;)

# Create an assistant
assistant = client.beta.assistants.create(
    instructions=assistant_prompt_instruction,
    model=&quot;gpt-4-1106-preview&quot;,
    tools=[{
        &quot;type&quot;: &quot;function&quot;,
        &quot;function&quot;: {
            &quot;name&quot;: &quot;tavily_search&quot;,
            &quot;description&quot;: &quot;Get information on recent events from the web.&quot;,
            &quot;parameters&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;properties&quot;: {
                    &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The search query to use. For example: &#x27;Latest news on Nvidia stock performance&#x27;&quot;},
                },
                &quot;required&quot;: [&quot;query&quot;]
            }
        }
    }]
)
assistant_id = assistant.id
print(f&quot;Assistant ID: {assistant_id}&quot;)

# Create a thread
thread = client.beta.threads.create()
print(f&quot;Thread: {thread}&quot;)

# Ongoing conversation loop
while True:
    user_input = input(&quot;You: &quot;)
    if user_input.lower() == &#x27;exit&#x27;:
        break

    # Create a message
    message = client.beta.threads.messages.create(
        thread_id=thread.id,
        role=&quot;user&quot;,
        content=user_input,
    )

    # Create a run
    run = client.beta.threads.runs.create(
        thread_id=thread.id,
        assistant_id=assistant_id,
    )
    print(f&quot;Run ID: {run.id}&quot;)

    # Wait for run to complete
    run = wait_for_run_completion(thread.id, run.id)

    if run.status == &#x27;failed&#x27;:
        print(run.error)
        continue
    elif run.status == &#x27;requires_action&#x27;:
        run = submit_tool_outputs(thread.id, run.id, run.required_action.submit_tool_outputs.tool_calls)
        run = wait_for_run_completion(thread.id, run.id)

    # Print messages from the thread
    print_messages_from_thread(thread.id)
</code></pre><p>The assistant can be further customized and improved using additional retrieval information, OpenAI’s coding interpreter and more. Also, you can go ahead and add more function tools to make the assistant even smarter.</p><p>Feel free to drop a comment below if you have any further questions!</p>]]></content>
        <author>
            <name>Assaf Elovic</name>
            <uri>https://github.com/assafelovic</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How we built GPT Researcher]]></title>
        <id>building-gpt-researcher</id>
        <link href="https://docs.gptr.dev/blog/building-gpt-researcher"/>
        <updated>2023-09-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[After AutoGPT was published, we immediately took it for a spin. The first use case that came to mind was autonomous online research. Forming objective conclusions for manual research tasks can take time, sometimes weeks, to find the right resources and information. Seeing how well AutoGPT created tasks and executed them got me thinking about the great potential of using AI to conduct comprehensive research and what it meant for the future of online research.]]></summary>
        <content type="html"><![CDATA[<p>After <a href="https://github.com/Significant-Gravitas/AutoGPT">AutoGPT</a> was published, we immediately took it for a spin. The first use case that came to mind was autonomous online research. Forming objective conclusions for manual research tasks can take time, sometimes weeks, to find the right resources and information. Seeing how well AutoGPT created tasks and executed them got me thinking about the great potential of using AI to conduct comprehensive research and what it meant for the future of online research.</p><p>But the problem with AutoGPT was that it usually ran into never-ending loops, required human interference for almost every step, constantly lost track of its progress, and almost never actually completed the task.</p><p>Nonetheless, the information and context gathered during the research task were lost (such as keeping track of sources), and sometimes hallucinated.</p><p>The passion for leveraging AI for online research and the limitations I found put me on a mission to try and solve it while sharing my work with the world. This is when I created <a href="https://github.com/assafelovic/gpt-researcher">GPT Researcher</a> — an open source autonomous agent for online comprehensive research.</p><p>In this article, we will share the steps that guided me toward the proposed solution.</p><h3>Moving from infinite loops to deterministic results</h3><p>The first step in solving these issues was to seek a more deterministic solution that could ultimately guarantee completing any research task within a fixed time frame, without human interference.</p><p>This is when we stumbled upon the recent paper <a href="https://arxiv.org/abs/2305.04091">Plan and Solve</a>. The paper aims to provide a better solution for the challenges stated above. The idea is quite simple and consists of two components: first, devising a plan to divide the entire task into smaller subtasks and then carrying out the subtasks according to the plan.</p><p><img src="./planner.jpeg" alt="Planner-Excutor-Model"/></p><p>As it relates to research, first create an outline of questions to research related to the task, and then deterministically execute an agent for every outline item. This approach eliminates the uncertainty in task completion by breaking the agent steps into a deterministic finite set of tasks. Once all tasks are completed, the agent concludes the research.</p><p>Following this strategy has improved the reliability of completing research tasks to 100%. Now the challenge is, how to improve quality and speed?</p><h3>Aiming for objective and unbiased results</h3><p>The biggest challenge with LLMs is the lack of factuality and unbiased responses caused by hallucinations and out-of-date training sets (GPT is currently trained on datasets from 2021). But the irony is that for research tasks, it is crucial to optimize for these exact two criteria: factuality and bias.</p><p>To tackle this challenges, we assumed the following:</p><ul><li>Law of large numbers — More content will lead to less biased results. Especially if gathered properly.</li><li>Leveraging LLMs for the summarization of factual information can significantly improve the overall better factuality of results.</li></ul><p>After experimenting with LLMs for quite some time, we can say that the areas where foundation models excel are in the summarization and rewriting of given content. So, in theory, if LLMs only review given content and summarize and rewrite it, potentially it would reduce hallucinations significantly.</p><p>In addition, assuming the given content is unbiased, or at least holds opinions and information from all sides of a topic, the rewritten result would also be unbiased. So how can content be unbiased? The <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers">law of large numbers</a>. In other words, if enough sites that hold relevant information are scraped, the possibility of biased information reduces greatly. So the idea would be to scrape just enough sites together to form an objective opinion on any topic.</p><p>Great! Sounds like, for now, we have an idea for how to create both deterministic, factual, and unbiased results. But what about the speed problem?</p><h3>Speeding up the research process</h3><p>Another issue with AutoGPT is that it works synchronously. The main idea of it is to create a list of tasks and then execute them one by one. So if, let’s say, a research task requires visiting 20 sites, and each site takes around one minute to scrape and summarize, the overall research task would take a minimum of +20 minutes. That’s assuming it ever stops. But what if we could parallelize agent work?</p><p>By levering Python libraries such as asyncio, the agent tasks have been optimized to work in parallel, thus significantly reducing the time to research.</p><pre><code class="language-python"># Create a list to hold the coroutine agent tasks
tasks = [async_browse(url, query, self.websocket) for url in await new_search_urls]

# Gather the results as they become available
responses = await asyncio.gather(*tasks, return_exceptions=True)
</code></pre><p>In the example above, we trigger scraping for all URLs in parallel, and only once all is done, continue with the task. Based on many tests, an average research task takes around three minutes (!!). That’s 85% faster than AutoGPT.</p><h3>Finalizing the research report</h3><p>Finally, after aggregating as much information as possible about a given research task, the challenge is to write a comprehensive report about it.</p><p>After experimenting with several OpenAI models and even open source, I’ve concluded that the best results are currently achieved with GPT-4. The task is straightforward — provide GPT-4 as context with all the aggregated information, and ask it to write a detailed report about it given the original research task.</p><p>The prompt is as follows:</p><pre><code class="language-commandline">&quot;{research_summary}&quot; Using the above information, answer the following question or topic: &quot;{question}&quot; in a detailed report — The report should focus on the answer to the question, should be well structured, informative, in depth, with facts and numbers if available, a minimum of 1,200 words and with markdown syntax and apa format. Write all source urls at the end of the report in apa format. You should write your report only based on the given information and nothing else.
</code></pre><p>The results are quite impressive, with some minor hallucinations in very few samples, but it’s fair to assume that as GPT improves over time, results will only get better.</p><h3>The final architecture</h3><p>Now that we’ve reviewed the necessary steps of GPT Researcher, let’s break down the final architecture, as shown below:</p><div align="center"><img align="center" height="500" src="https://cowriter-images.s3.amazonaws.com/architecture.png"/></div><p>More specifically:</p><ul><li>Generate an outline of research questions that form an objective opinion on any given task.</li><li>For each research question, trigger a crawler agent that scrapes online resources for information relevant to the given task.</li><li>For each scraped resource, keep track, filter, and summarize only if it includes relevant information.</li><li>Finally, aggregate all summarized sources and generate a final research report.</li></ul><h3>Going forward</h3><p>The future of online research automation is heading toward a major disruption. As AI continues to improve, it is only a matter of time before AI agents can perform comprehensive research tasks for any of our day-to-day needs. AI research can disrupt areas of finance, legal, academia, health, and retail, reducing our time for each research by 95% while optimizing for factual and unbiased reports within an influx and overload of ever-growing online information.</p><p>Imagine if an AI can eventually understand and analyze any form of online content — videos, images, graphs, tables, reviews, text, audio. And imagine if it could support and analyze hundreds of thousands of words of aggregated information within a single prompt. Even imagine that AI can eventually improve in reasoning and analysis, making it much more suitable for reaching new and innovative research conclusions. And that it can do all that in minutes, if not seconds.</p><p>It’s all a matter of time and what <a href="https://github.com/assafelovic/gpt-researcher">GPT Researcher</a> is all about.</p>]]></content>
        <author>
            <name>Assaf Elovic</name>
            <uri>https://github.com/assafelovic</uri>
        </author>
    </entry>
</feed>